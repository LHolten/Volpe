// (env -> ()) -> env -> ()
A: 1

// env -> ()
A



if = #{if @0 else @1 end};

loop func = #{loop @0 end} (func #{br});

until cond func = (cond; if func {});


range n func = (
    i := 0; // strict assign
    #{loop @0 end} (
        func i;
        i := (i + 1);
        #{br_if(neq(i n))}
    );
)






factorial = n.(
    {a} = 1; // strict assign
    range n i.(
        {a} : a * i; // mutate variable
    );
    {a} // return lazy
);


name = "";
value = 0;

object1 = (
    name : "alpha";
    value : 42;
);

object2 = (
    name : "beta";
);


get_name = object.(
    object name
);

name1 = get_name object1;



value = 1;
alpha = value;
alpha : 2;
value // is now 1


value = 1;
alpha = value;
value : 2;
alpha // is now 2



object = val.(
    Val : val;
);

one = {object} 1;
two = {object} 2;

{one Val} 3;

two Val // is still 2
one Val // is now 3



for iter func


factorial = (
    {A: 1};
    loop {
        N: N - 1;
        A: A * N
    };
    until (N <= 1)
)






obj = (A: 10; B: 20);
alpha = obj A;
beta = obj B;
sum = obj (int A + B);



# () requires one argument which is the continuation
# a (b) c == a b c
# a:v requires one argument which is the continuation
# the single continuation argument is right associative
# c b a = a; b; c
# add x y = x; y; add
# apply f:(mul 2) 10



(range 0 10) each.i do:(...)
(range 0 10) each.i (...)
(range 0 10).each i:(...)
(range 0 10) 


add.res: (
    res: x y
);

add.sum x:10 y:20


for.val in:(range 0 10) do:(
    res: min res val
);

obj: (

)






range: iterator
    each:
        



(range 0 10).each i.(
    (range 0 10).each j:(
        
    )
); 
;
each0

range: (
    each: (
        # if top 2 values are equal then quit
        # duplicate top value
        do
        # increment top value
        # loop
    );
    iterator
)


add: (
    res: add.x + add.y
)

x: 10
add(x y: 20) res:
...







test:res:(a b add);

obj:(a:10 b:20)

obj test