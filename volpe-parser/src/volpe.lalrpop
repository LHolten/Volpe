use std::str::FromStr;
use std::rc::Rc;
use crate::ast::*;

grammar;

Left<O, N>: Term = LeftOptional<O, N> O N => Term::Op(Op::new(<>));

LeftOptional<O, N>: Term = {
    LeftOptional<O, N> O N => Term::Op(Op::new(<>)),
    N,
};

Comma<T>: Vec<T> = <v:(<T> ",")*> <e:T> ","? => {
    let mut v = v;
    v.push(e);
    v
};

pub Expr: Term = {
    <(<App_> "=")*> <App_> ";" <Expr> => Term::Stmt(Stmt::new(<>)),
    <App_> "=>" <App_> ";" <Expr> => Term::Ite(Ite::new(<>)),
    <App_?> => if let Some(val) = <> {val} else {Term::Id},
}

Matrix: Vec<Vec<Term>> = <v:(<Row> ";")*> <e:Row?> => match e {
    None => v,
    Some(e) => {
        let mut v = v;
        v.push(e);
        v
    }
};
Row = Comma<App_>;

pub Object = Comma<Entry>;
Entry: Entry = <attr:App_> ":" <val:App_> => Entry{<>};

Tuple: Vec<Term> = <v:(<App_> ",")*> <e:App_?> => match e {
    None => v,
    Some(e) => {
        let mut v = v;
        v.push(e);
        v
    }
};

App_ = LeftOptional<AppOp, Func_>;
AppOp: OpCode = () => OpCode::App;

Func_: Term = {
    Or_ FuncOp Func_ => Term::Op(Op::new(<>)),
    Or_,
};
FuncOp: OpCode = "." => OpCode::Func;

Or_ = LeftOptional<OrOp, And_>;
OrOp: OpCode = "||" => OpCode::Or;

And_ = LeftOptional<AndOp, Applicable_>;
AndOp: OpCode = "&&" => OpCode::And;

Applicable_ = {Equal, Cmp, Equable_};

Equal: Term = Equable_ (EqualOp Equable_)+ => Term::EqualOp(MultiOp::new(<>));
EqualOp: EqualOp = {
    "==" => EqualOp::Equal,
    "!=" => EqualOp::Unequal,
};
Equable_ = {BitOr, BitAnd, BitXor, Shift, Comparable_};

Cmp: Term = Comparable_ (CmpOp Comparable_)+ => Term::CmpOp(MultiOp::new(<>));
CmpOp: CmpOp = {
    "<" => CmpOp::Less,
    ">" => CmpOp::Greater,
    "<=" => CmpOp::LessEqual,
    ">=" => CmpOp::GreaterEqual,
};
Comparable_ = {Add, Mul, Term};

Add = Left<AddOp, Mul_>;
AddOp: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

Mul = Left<MulOp, Term>;
Mul_ = LeftOptional<MulOp, Term>;
MulOp: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
    "%" => OpCode::Mod,
};

BitOr = Left<BitOrOp, BitAnd_>;
BitOrOp: OpCode = "|" => OpCode::BitOr;

BitAnd = Left<BitAndOp, Term>;
BitAnd_ = LeftOptional<BitAndOp, Term>;
BitAndOp: OpCode = "&" => OpCode::BitAnd;

BitXor = Left<BitXorOp, Term>;
BitXorOp: OpCode = "^" => OpCode::BitXor;

Shift = Left<ShiftOp, Term>;
ShiftOp: OpCode = {
    "<<" => OpCode::BitShl, 
    ">>" => OpCode::BitShr,
};

Term: Term = {
    Num => Term::Num(<>),
    Ident => Term::Ident(<>),
    "(" <Expr> ")",
    "[" <Matrix> "]" => Term::Matrix(<>),
    "{" <Object> "}" => Term::Object(<>),
    "{" <Tuple> "}" => Term::Tuple(<>),
};

Ident: Rc<String> = r"[_a-zA-Z][_a-zA-Z0-9]*\??" => Rc::new(<>.to_string());

Num: u64 = r"[0-9]+" => u64::from_str(<>).unwrap();