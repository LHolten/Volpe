use std::str::FromStr;
use std::rc::Rc;
use crate::ast::*;

grammar;

Left<O, N>: Term = LeftOptional<O, N> O N => Term::Op(Op::new(<>));

LeftOptional<O, N>: Term = {
    LeftOptional<O, N> O N => Term::Op(Op::new(<>)),
    N,
};

Comma<T>: Vec<T> = <v:(<T> ",")+> <e:T?> => match e {
    None => v,
    Some(e) => {
        let mut v = v;
        v.push(e);
        v
    }
};

pub Expr: Expr = <(<Stmt> ";")*> <App_?> => Expr::new(<>);
Stmt: Stmt = <var:(<App_> "=")*> <val:App_> => Stmt{<>};

Matrix: Vec<Vec<Term>> = <v:(<Row> ";")*> <e:Row?> => match e {
    None => v,
    Some(e) => {
        let mut v = v;
        v.push(e);
        v
    }
};
Row = Comma<App_>;

Object = Comma<Entry>;
Entry: Entry = <attr:App_> ":" <val:App_> => Entry{<>};

App_ = LeftOptional<AppOp, Or_>;
AppOp: OpCode = () => OpCode::App;

Or_ = LeftOptional<OrOp, And_>;
OrOp: OpCode = "||" => OpCode::Or;

And_ = LeftOptional<AndOp, Applicable_>;
AndOp: OpCode = "&&" => OpCode::And;

Applicable_ = {Equal, Cmp, Equable_};

Equal: Term = Equable_ (EqualOp Equable_)+ => Term::EqualOp(MultiOp::new(<>));
EqualOp: EqualOp = {
    "==" => EqualOp::Equal,
    "!=" => EqualOp::Unequal,
};
Equable_ = {BitOr, BitAnd, BitXor, Shift, Comparable_};

Cmp: Term = Comparable_ (CmpOp Comparable_)+ => Term::CmpOp(MultiOp::new(<>));
CmpOp: CmpOp = {
    "<" => CmpOp::Less,
    ">" => CmpOp::Greater,
    "<=" => CmpOp::LessEqual,
    ">=" => CmpOp::GreaterEqual,
};
Comparable_ = {Add, Mul, Func_};

Add = Left<AddOp, Mul_>;
AddOp: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

Mul = Left<MulOp, Func_>;
Mul_ = LeftOptional<MulOp, Func_>;
MulOp: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
    "%" => OpCode::Mod,
};

BitOr = Left<BitOrOp, BitAnd_>;
BitOrOp: OpCode = "|" => OpCode::BitOr;

BitAnd = Left<BitAndOp, Func_>;
BitAnd_ = LeftOptional<BitAndOp, Func_>;
BitAndOp: OpCode = "&" => OpCode::BitAnd;

BitXor = Left<BitXorOp, Func_>;
BitXorOp: OpCode = "^" => OpCode::BitXor;

Shift = Left<ShiftOp, Func_>;
ShiftOp: OpCode = {
    "<<" => OpCode::BitShl, 
    ">>" => OpCode::BitShr,
};

Func_: Term = {
    Term FuncOp Func_ => Term::Op(Op::new(<>)),
    Term,
};
FuncOp: OpCode = "." => OpCode::Func;

Term: Term = {
    Num => Term::Num(<>),
    Ident => Term::Ident(<>),
    "(" <Expr> ")" => Term::Expr(<>),
    "[" <Matrix> "]" => Term::Matrix(<>),
    "{" <Object> "}" => Term::Object(<>),
};

Ident: Rc<String> = r"[_a-zA-Z][_a-zA-Z0-9]*" => Rc::new(<>.to_string());

Num: u64 = r"[0-9]+" => u64::from_str(<>).unwrap();