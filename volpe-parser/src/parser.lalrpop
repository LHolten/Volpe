use std::str::FromStr;
use crate::ast::*;

grammar;

Left<O, N>: Term = LeftOptional<O, N> O N => Term::new_op(<>);

LeftOptional<O, N>: Term = {
    LeftOptional<O, N> O N => Term::new_op(<>),
    N,
};

Comma<T>: Vec<T> = <v:(<T> ",")*> <e:T> ","? => {
    let mut v = v;
    v.push(e);
    v
};

pub Expr: Term = {
    <(<App_> "=")*> <App_> ";" <Expr> => Term::new_stmt(<>),
    <App_> "=>" <App_> ";" <Expr> => Term::new_ite(<>),
    <App_> "=>" <App_> => Term::new_assert(<>),
    <App_>,
}

Matrix: Vec<Vec<Term>> = <v:(<Row> ";")*> <e:Row?> => match e {
    None => v,
    Some(e) => {
        let mut v = v;
        v.push(e);
        v
    }
};
Row = Comma<App_>;

pub Object = Comma<Entry>;
Entry: Entry = <attr:App_> ":" <val:App_> => Entry{<>};

Tuple: Vec<Term> = <v:(<App_> ",")*> <e:App_?> => match e {
    None => v,
    Some(e) => {
        let mut v = v;
        v.push(e);
        v
    }
};

App_ = LeftOptional<AppOp, Func_>;
AppOp: Op = () => Op::App;

Func_: Term = {
    Or_ FuncOp Func_ => Term::new_op(<>),
    Or_,
};
FuncOp: Op = "." => Op::Func;

Or_ = LeftOptional<OrOp, And_>;
OrOp: Op = "||" => Op::Bool(BoolOp::Or);

And_ = LeftOptional<AndOp, Applicable_>;
AndOp: Op = "&&" => Op::Bool(BoolOp::And);

Applicable_ = {Equal, Cmp, Equable_};

Equal: Term = Equable_ (EqualOp Equable_)+ => Term::new_multi_op(<>);
EqualOp: Op = {
    "==" => Op::Int(IntOp::Equal),
    "!=" => Op::Int(IntOp::Unequal),
};
Equable_ = {BitOr, BitAnd, BitXor, Shift, Comparable_};

Cmp: Term = Comparable_ (CmpOp Comparable_)+ => Term::new_multi_op(<>);
CmpOp: Op = {
    "<" => Op::Int(IntOp::Less),
    ">" => Op::Int(IntOp::Greater),
    "<=" => Op::Int(IntOp::LessEqual),
    ">=" => Op::Int(IntOp::GreaterEqual),
};
Comparable_ = {Add, Mul, Term};

Add = Left<AddOp, Mul_>;
AddOp: Op = {
    "+" => Op::Int(IntOp::Add),
    "-" => Op::Int(IntOp::Sub),
};

Mul = Left<MulOp, Term>;
Mul_ = LeftOptional<MulOp, Term>;
MulOp: Op = {
    "*" => Op::Int(IntOp::Mul),
    "/" => Op::Int(IntOp::Div),
    "%" => Op::Int(IntOp::Mod),
};

BitOr = Left<BitOrOp, BitAnd_>;
BitOrOp: Op = "|" => Op::Int(IntOp::BitOr);

BitAnd = Left<BitAndOp, Term>;
BitAnd_ = LeftOptional<BitAndOp, Term>;
BitAndOp: Op = "&" => Op::Int(IntOp::BitAnd);

BitXor = Left<BitXorOp, Term>;
BitXorOp: Op = "^" => Op::Int(IntOp::BitXor);

Shift = Left<ShiftOp, Term>;
ShiftOp: Op = {
    "<<" => Op::Int(IntOp::BitShl), 
    ">>" => Op::Int(IntOp::BitShr),
};

Term: Term = {
    Num => Term::Num(<>),
    Ident => Term::Ident(<>),
    "(" <Expr> ")",
    "[" <Matrix> "]" => Term::Matrix(<>),
    "{" <Object> "}" => Term::Object(<>),
    "{" <Tuple> "}" => Term::Tuple(<>),
};

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*\??" => <>.to_string();

Num: u64 = r"[0-9]+" => u64::from_str(<>).unwrap();

// Comments
match {
    r"\s*" => { }, // ignore whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // ignore `// ...`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // ignore `/* ... */`
    _
}
